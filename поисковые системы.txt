   Если рассматривать более детально механизмы поисковых систем - эти механизмы имеют более сложную структуру и более широкие области применения чем, это кажется на первый взгляд.
Таким образом можно классифицировать механизмы поисковых систем.

Например, это могут быть такие области примерения как:
----
1.1 хеширование данных запросов на клиентской (и даже на серверной) стороне.
    Такой способ поиска позволяет иметь быстрый поиск-доступ к данным только в том случае если ранее уже известен сам объект-поиска...
1.2 поиск объект-ов в заданом диапазоне (бинарный поиск, по сбалансированому дереву).
    На тот случай если ранее еще неизвестно существование объектов...
Такой способ поиска имеет свои достоинства и недостатки:
- достоинство в том, что поиск-доступ к данным выполняется за очень быстрое время.
- а недостатки такого способа в том что:
  * требуется много ресурсов (чтобы держать объекты в оперативной памяти).
  * и независимо от того сколько много ресурсов (по оперативной памяти) существует, всегда будет существовать невысокий предел по ограничению объема данных по сравнению с дисковым пространством.
  * после отключения все данные пропадают.
2.1 поиск обектов используя специальные алгоритмы-сортировки.
2.2 организация много-поточного поискового механима (обычно на 1-поток процессор тратит меньше 1% своего времени, а чтобы увеличить этот коефициент...).
И такой способ поиска тоже имеет свои достоинства и недостатки:
- недостатки в том, что:
  * все таки затрачиваемое время-доступа для объекта будет больше.
  * такой способ более сложнее...
- а достоинство такого способа в том что:
  * полная сохраность и востановление данных после отключения...




  Применяем в:
  1. В веб-браузере, это клиентское приложение, которое хеширует в клиентскую историю посещаемые страницы (объекты/веб-страницы).
  2. Клиентские сессии, сервер-приложений по данным клиента генерит хеш-номер уникальной сессии (клиента) - именно этот хеш-номер является именем файла на серверной стороне в
     котором временно хранится информация о коиенте (это поля с клиентскими данными).
     То есть, веб-приложение на сервере-приложений, может быть одно, а клиентских сессий (клиентов) может быть тысячи...
  3. Телефонная компания - где тысячи-милионы людей в каждую секунду пытаются созвонится между собой.
     Поэтому и существуют такие "соты" (сервера) которые распределяют нагрузку клиентских вызовов. Такие сервера имеют раздельные базы данных (узлы) куда стекается информация,
     но потом существует поисковой сервис, который распаралеливает поиск данных по запросу (в многопоточном режиме...).
     - Так работают все современные поисковые системы (Google, Yandex, ...): в каждом районе провайдеры поддерживают собственную базу данных.
  4. Для построения Более надежных поисковых систем применяется уже сложные механизмы реализации (клиент-серверная архитектура):
     - на серверной стороне стоят огромные дисковые накопители:
       * для обеспечения надежного хранения данных и в боольших объеммах используются файлы на дисковых устройствах...
       * а поиск-доступ к данным реализован с помощю спецальных алгоритмов поиска и хеширования клиентских запросов (которые ускоряют поиск данных)...
       * а также применяются многопоточные задачи для работы с большим количеством клиентов одновременно...
     - на клиентской стороне (достаточно минимум ресурсов):
       * должно быть специальное клиентское приложение которое умеет связываться с сервером и обмениваться данными (понимать команды)...
       * уметь делать форматный вывод/представление данных и корректно отвечать на исключительные ситуации в случае ошибок...

   Дело в том, что изначально эти алгоритмы и хеш-функции предназначались для применения в других целях:
- Хеш-функция по объекту (поля с данными которые лежат внутри этого объекта) может генерить хеш-сумму (специальное число-номер) по которому можно судить о равенстве этих объектов.
  Например:
  * при копировании объектов (особено по сети) чтобы подтвердить успешность копирования данных/файлов без потери данных хеш-сумме.
  * хеш-функция позволяет хранить клиентские ключи/пароли (где-то на сервере) в зашифровнном виде (чтобы даже сам влвделец-администратор не мог им воспользоваться).
  * хеш-функция по клиентским данным (IP-адресс...) определяет хеш-сумму и на стороне сервера-приложений создает файл с таким-же именем, внутри которго будут храниться клиентские
    данные - такой механизм называется "сессией".
  * на клиентском веб-броузере создается хеш-таблица посещаемых страниц - это механизм хеширования - и потом такие объекты (хеш-таблица) сериализируется-сохраняется в файл на
    клиентской стороне. Такие хеш-таблицы объектов клиентских посещаемых страниц имеют небольшой-маленький размер (несмотря на то что они сериализируется-сохраняется в файл),
    и позволяют восстанавливать последнее состояние клиентского веб-боаузера позле выключения.
  По своей природе такая хеш-функция это есть просто формула (в которую подставляются текущие клиентские данные).
- Алгоритмы, это (это не фомула) разработанная специальная схема по которой в цыклическом режиме выполняются заданые действия. Изначально алгоритмы разрабатывались для сортировки
  пользовательских данных, чтобы иметь возможность получить быстрый доступ/поиск в списках.
  Алгоритмы могут быть "обратимые" (которые позволяют вернуть исходное состояние) и "необратимые" (уже никогда неудастся вернуться к исходному состоянию).
  Такой механизм работает по принципу кубика-рубика, например:
  * для генерирования более защищенного ключа/пароля (как выяснилось, такой способ шифрования является более сложным для взлома системы..., потому-что теретически невозможно
    предугадать зашифроаную комбинацию, даже в случае если известен сам алгоритм шифрования) - это пример необратимого шифрования.
  * для шифрования канала передачи данных (обычно такой алгоритм сортировки только частично шифрует данные, так чтобы потом можно было повторить обратные действия) - это пример
    необратимого шифрования.

   Дело в том, что изначально многопоточные приложения предназначались для того чтобы сбалансировать скорость выполнения для множества вычислительных задач.
   Например:
- смоделировать физическая среду в природе (вода/речка/океан, ветер/ураганы, слоистые породы грунта для конкретной местности, извержения вулканов, ...)
- смоделировать поведения какого-нибудь агрегата в среде (эксперементальный самолет, космический шатл, морской корабль-лайнер, ...)
- а также это может быть большая компьютерная видео-игра где одновремено могут быть задействованы тысячи разных объектов.
  В этом случае чтобы получить максимально приближеную реалистическую модель применяются многопоточные модули для распаралеливания процессов.

А в случаях при работе с базами данных:
- по своей природе "база данных" это есть очень мощный поисковый механизм, который позволяет надежно  хранить терабайты информации (востанавливать ее даже после выключения) и
  предоствлять очень быстрый доступ/поиск с гибкими параметрами клиенского фильтрования по заданому диапазону.
  И даже применяя все эти способы поиска: хеш-функции, алгоритмы сортировки, сбалансированые/бинарные деревья (для поиска в заданом диапазоне), файловая структура пространства имен
  (для распределения типа данных, чтобы файлы сделать меньше размеров) - для работе с терабайтами информации скорость поиска при таких высоких нагрузках будет очень медленой:
  * количество клиентских каналов для передачи данных по сети (сеть так-же имеет ограничеие пропускной способности...)
  * на чтение файлов с размером в сотни-терабайт всегда будет занимать много времени (потому-что физические устройства имеют ограничения по скорости...)
  По этой причине применяются распределение многопоточности в задачах. То есть, на сервере выплняются еще и какие-нибудь другие задачи, поэтому обычно процессор на сервере
  тратит меньше 1% (0.1%) своего времени на каждую задачу... И для того чтобы быстрее выполнялось приложение - нужно чтобы процессор тратил больше 1% (30%) своего времени только
  на эту-нашу задачу.
  Например:
  ** создать отдельных 100-потоков для чтения-поиска данных в файле который имеет размер 100-терабайт...
  ** ограничить количество клиентских каналов для одновременного доступа по сети до 10-пуллов (поскольку в каждый момент времени не все клиенты будут активны...)
  ** создать правила для "уровней изоляции" (чтобы клиентские транзакции разбить по приоритетам...)
  ** базы хранить на разных серверах-машинах... (по своей природе - сервер - это только узел куда стекается информация)

Еще в базах данных широко используется команда "индексации таблиц":
- если представить себе что каждый объектный файл базы данных представляет собой таблицу с полями (колонками), - тогда внутри файла такие данные/записи могут хранится в отдельных
  строках, а сами же колонки отделяться друг от друга (например) табуляцией.
  Итак, команда "индексации таблиц" представляет собой алгоритм сортировки записей по определенному столбцу внутри файла. Конечно же такая процедура, и особенно внутри файла,
  занимает очень много времени в зависимости от размера данных которые хранятся в этом файле, но в результате выполнения такой операции доступ-поиск данных внутри файла будет
  занимать гораздо меньше времени...

Еще один интересный факт: все десктопные/консольные большие-серъезные разрабатываемые видео-игры (не интернет-игры) имеют собственные базы данных и причем это уже аж никак не
стандартные базы данных (накштаут: MySQL, MSSQL, Oracle, Postgres, ...).
  Дело в том, что каждая компания, которая разрабатывает и выпускает свою такую видео-игру, также и разрабатывает для нее специфическую-уникальную базу данных, - которая имеет
свой собственный формат данных и хранит там информацию об уровнях, это может быть например:
- модели объектов (монстры, спец-техника, вооружение);
- новые лабиринты, деревъя, постройки домов, разные сцены: природа...;
- доступные новое вооружения, боеприпасы, здоровъе...;
Такие базы данных не нуждаются в распределеной структуре (клиент-серверной архитектуре, как: MySQL, MSSQL, Oracle, Postgres, ...), они ограничены только локальным специфическим
сервисом, которая помогает загружать новые игровыне уровни...

Еще в многопоточных системах для обмена данных между разными процессами разработан специальный механизм, который называется - "очередь сообщений" (например):
- внутри операционной системы паралельно могут работать много запущеных клиентских приложений/процессов:
  * это могут быть офисные приложения, клиентские почтовики, скайп для обмена мгновенными сообщениями, торрент для загрузки данных, программа-калькулятор, веб-броузер внутри
    которого может быть открыт чат, браузерная онлайн-игра, программа-проводник (фар-менеджер), и другие фоновые процессы (сканеры-антивирусы, позиция перемещения курсора
    мишки/джостика, реакция на нажатие по клавише на клавиатуре, низкий уровень заряда АКБ)... То есть, любое событие в системе генерит сообщение.
  * все такие программы генерят собственные/специальные сообщения в операционную систему для запроса/доступа к какому нибудь ресурсу или формирования отчетов об ошибках...
      В свою же очередь операционная система объязана словить все эти сообщения и направить их требуемому адрессату... - такая процедура требует постоянного поиска адресатов для
    обмена сообщениями.
      Дело в том (это и есть основная идея...) что каждое отдельное приложение (любое: фоновое/нефоновое) паралельно работает как самостоятельный модуль. То есть, в этом случае
    операционной системе незачем тратить свое время на поиск адрессатов для сообщений, потому-что таким поиском занимаются сами-же эти адрессаты/программы - они параллельно в
    процессе своей работы просто слушают/сканируют общую "очередь сообщений" и если находится сообщение которое адресовано этой программе - тогда такое сообщение передается из
    общей "очереди сообщений" в эту программу...
- в видео-игре тоже существует многопоточность для множества объектов которые здесь принимают участие (это могут быть: игроки-монстры, механическая техника, вода, ветер, снаряды,
  команда/группа строителей/воинов, отдельные механизмы автомобиля калеса/кузов, ...):
  * и незаметно для основного игрока в такой видео-игре в фоновом режиме может генериться тысячи разных сообщений от объектов-адрессатов в которых говорится что какие-то процессы
    либо уже заершены либо начали выполняться (например: столкновение автомобилей, попадание снаряда, или повор руля, удар оружием по противнику)...
  * чтобы обмениваться такими сообщениями ненужно создавать еще одну новую задачу для этого в видео-игре..., потому что уже существуют объекты-слушатели (адрессаты) этих сообщений.
    Поэтому в видео-игре для обмена сообщениями между многопоточными процессами создается общая "очередь игровых сообщений" - такой себе стек объектов-сообщений. А вот уже
    сами адресаты-сообщений выдергивают из этого стека-сообщений именно то сообщение которое ему адресуется.
Такой механизм распаралеливания многопоточных задач является экономичным и очень эффективным при работе с очень большими объемами данных, например:
- поскольку сервер, представляет собой некий узел куда стекается информация, и если таких серверов (узлов будет много) и они будут логировать/сохранять/собирать какую-то часть
  клиентских данных (как напрмер: платежные терминалы для выдачи денег по всему городу и по всем странам, или провайдеры которые преоставляют своим клиентам доступ к глобальной
  и-нет сети, или соты для мобильной связи...).
    Таким способом, если разместить на всех этих узлах например отдельные поисковые модули - это позволит раздельно выполнять глобальный поиск клиентских данных за очень короткое
  время, а результаты поиска могу собираться в любом конкретном (независимом) месте...
    Именно по такому принципу и работают современные поисковые системы (Google, Yandex, ...).
   Кроме это, по такому же принципу работают и современные клиентские репозитории (хранилища), например: "Torrent" (здесь уже каждый клиент является источником поиска...)






















