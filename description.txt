
------------------------------------------------------------------------------------------------------------------------
(Java аннотации. Пример 1) http://study-and-dev.com/blog/java_annotations_example_1/
           (oop: overload) http://kharkovitcourses.blogspot.com/2012/08/oop-overload.html

***          (HashMap и HashSet. Что это на самом деле?) http://devcolibri.com/4385
                            (HashMap Java собеседование) https://www.youtube.com/watch?v=Z0JMABjXnww
    (Красно черные деревья Алгоритмы Java собеседование) https://www.youtube.com/watch?v=38h3w7RwR-M
                                                         https://www.youtube.com/watch?v=-gKLTH0KTF4
                                                         https://www.youtube.com/watch?v=85a-sHg5otU
                         (Java собеседование. Коллекции) http://wayofdev.blogspot.com/p/blog-page_16.html
                                                         http://habrahabr.ru/post/162017/
                 (Структуры данных в картинках. HashMap) http://habrahabr.ru/post/128017/
              (Структуры данных в картинках. LinkedList) http://habrahabr.ru/post/127864/
           (Структуры данных в картинках. LinkedHashMap) http://deadlock.org.ua/kit/habr/post/984
           (В чем отличия реализации TreeMap и HashMap?) http://www.cyberforum.ru/java-j2se/thread592648.html
                   (Коллекции (Collections) в Java. Map) http://www.seostella.com/ru/article/2012/08/09/kollekcii-collections-v-java-map.html

                  (Руководство по Java ** Класс HashSet) http://metanit.com/java/tutorial/5.4.php
                          (Java / HashMap для junior-ов) http://www.quizful.net/interview/java/hashmap-juniors

(Теория и практика Java: Исправление модели памяти Java, часть 2) http://www.ibm.com/developerworks/ru/library/j-jtp03304/
                                                                  http://gee.cs.oswego.edu/dl/cpj/jmm.html

------------------------------------------------------------------------------------------------------------------------
(java исключения checked и unchecked)
http://interviewinit.com/?p=418
http://www.golovachcourses.com/exceptions-checked-unchecked/
https://dev64.wordpress.com/2012/10/07/exception-handling-antipatterns/
http://habrahabr.ru/company/golovachcourses/blog/223821/
http://kostin.ws/java/java-exceptions.html
http://habrahabr.ru/company/golovachcourses/blog/225585/














В действительности-же, операция копирование файлов является более сложной (чем это кажется на первый взгляд).
Нужно начать с того, что эта операция расчитана на направление транспортировки данных. И в этом случае принимают участие много разных устройств:
- "файл источник" (по сути источником может служить не только файл, это может быть и клавиатура/джойстик, USB/IR-порт, WiFi, сетевая карта ин-нет/локальная сеть, сканер, ...)
- "файл приемник" (по сути приемник может служить не только файл, это может быть и видеокарта, USB/IR-порт, WiFi, сетевая карта ин-нет/локальная сеть, принтер, ...)
- "(программный) инструмент для чтения/записи данных"
- "протокол передачи/транспортировки данных" (канал ранспортировки данных, это все те промежуточные устройства которые участвуют в транспортирове данных: шина, кабель, порт, инструмент формирования/разборки пакетов, шифорвание данных, ...)
При условии что в какой-то момент времени устройство (которое участвует в трансортировке данных) может быть зайнято другой операцией и недоступно.
В результате прохождения (транспортирования) данных по такой сложной схеме на приемное устройство данных поступают с опозданием (в одно время - передача может проходить быстро, в другое время - передача может быть медленная, в третее время - передача может отсутствовать...).

Дело в том, что обычно приемное устройство должно работать в нормальном стабильном режиме для приема данных, но компьютер не может обеспечить стабильную скорость передачи данных... - именно по этой причине применяется буферизация (аккумуляция/накопление) данных, с целью обеспечить стабильную скорость подачи данных на устройство-приемник.
Такой буфер обычно стоит на стороне устройства-приемника (и выполняет роль стабилизатора скорости для подачи транспортируемых данных).


------------------------------------------------------------------------------------------------------------------------
Потоки представляют собой экземпляры классов, каждый из которых запускается и функционирует самостоятельно, автономно (дновременное выполнение нескольких задач, каждой в независимом потоке) от главного потока выполнения программы.

Существует два способа создания и запуска потока:
1. на основе расширения класса "Thread";
   — при реализации интерфейса "Runnable" необходимо определить его единственный абстрактный метод "run()". (Интерфейс "Runnable" не имеет метода "start()" а только единственный метод "run()")
2. или реализации интерфейса "Runnable";
   — для запуска такого потока ("Runnable") следует создать экземпляр класса "Thread" с передачей экземпляра "Runnable" его конструктору. Однако при прямом вызове метода "run()" поток не запустится, выполнится только тело самого метода.

Жизненный цикл потока — в процессе выполнения поток может находится в одном из нескольких возможных состояний:
1. "NEW" ............. поток создан, но еще не запущен;
2. "RUNNABLE" ........ поток выполняется;
3. "BLOCKED" ......... поток блокирован;
4. "WAITING" ......... поток ждет окончания работы другого потока;
5. "TIMED WAITING" ... поток некоторое время ждет окончания другого потока;
6. "TERMINATED" ...... поток завершен;
